# Принципы "Функциональной ясности"

## 1. Ограниченная зона ответственности

**Принцип**: Каждый модуль, класс или функция должны решать одну конкретную задачу и иметь четко определенную область ответственности.

Функции с ограниченной зоной ответственности проще понять, тестировать и модифицировать. Когда компонент делает только одно дело, изменения в нем с меньшей вероятностью повлияют на другие части системы. Ограничивайте длину функций до 20-30 строк и фокусируйтесь на единственной задаче.

## 2. Экономия ресурсов через минимальные изменения

**Принцип**: Исходите из высокой стоимости переделывания существующего кода и проектируйте решения, требующие минимальных изменений при максимальной пользе.

Переделывание кода — дорогостоящая операция как с точки зрения времени, так и рисков. Всегда начинайте с понимания существующих абстракций и механизмов, расширяйте их, а не создавайте параллельные системы. Каждое изменение должно делать систему более подготовленной к будущим изменениям, снижая их стоимость.

## 2A. Архитектура Fail-Fast: Feature Flags как единственное исключение

**Принцип**: Система должна падать немедленно при любых ошибках. Graceful degradation возможен только через feature flags.

**Железное правило**:
- Feature flag выключен → early return (None/0/skip)
- Feature flag включен → функциональность обязательна → ошибки падают

**Это значит**:
- Нет try-catch для "на всякий случай"
- Нет "если не получилось, ничего страшного"
- Нет default-значений при ошибках
- Нет логирования без re-raise

**Паттерн реализации**:
```python
def process_with_feature(data):
    """Process data if feature enabled."""
    # ЕДИНСТВЕННЫЙ легитимный early return
    if not settings.FEATURE_ENABLED:
        logger.debug('Feature disabled, skipping')
        return 0

    # После этой точки - feature включен = функциональность обязательна
    # Любые ошибки ДОЛЖНЫ падать, не обрабатывай их здесь
    result = _do_actual_work(data)  # Let exceptions bubble up
    return result

def _do_actual_work(data):
    """Protected method with business logic - no feature checks."""
    # Fail fast validation
    if not data:
        raise ValidationError('data is required')

    # Business logic - no try-catch, let it fail
    return external_service.process(data)
```

**Почему это важно**:
Error Hiding создает иллюзию стабильности при скрытых критических проблемах. Системы с graceful degradation сложнее отлаживать и поддерживать.

## 3. Архитектура, поддерживающая изменения

**Принцип**: Проектируйте изменения так, чтобы они уменьшали стоимость будущих доработок, а не только решали текущую задачу.

Любое изменение должно не только решать текущую задачу, но и делать систему более подготовленной к будущим изменениям. Хорошее решение должно сокращать объем кода, повышать его повторное использование и упрощать добавление похожей функциональности в будущем. В условиях ограниченных ресурсов это критически важно: хорошо спроектированное сегодняшнее изменение экономит многократно больше времени при последующей разработке.

## 4. Явная обработка ошибок

**Принцип**: Применяйте подход fail-fast при невалидных входных данных, используйте информативные классы исключений и подробные сообщения об ошибках. См. принцип 2A для общей архитектуры обработки ошибок.

**Применение**:
- Проверяйте условия в начале функций (fail-fast validation)
- Создавайте собственные классы исключений с говорящими названиями и содержательными сообщениями
- Структурируйте исключения в иерархию для более гибкой обработки различных типов ошибок
- Явная обработка ошибок делает код более предсказуемым и упрощает отладку

## 5. Минимальные зависимости

**Принцип**: Минимизируйте внешние зависимости и инкапсулируйте их для снижения связанности компонентов.

Предпочитайте стандартную библиотеку, избегайте излишних абстракций, инкапсулируйте внешние зависимости через фабрики и сервисы. Код с минимальными зависимостями проще тестировать, понимать и поддерживать. При необходимости введения внешних зависимостей изолируйте их за интерфейсами.

## 6. Предметно-ориентированное обобщение

**Принцип**: Обобщайте функциональность по смысловой принадлежности к предметной области, а не по технической схожести.

Группируйте функции по их смысловому контексту, а не по технической реализации. Организуйте код по функциональным областям, а не техническим слоям. Такая организация улучшает понимание бизнес-логики системы и упрощает навигацию по коду. Избегайте утилитарных функций без чёткого контекста.

## 7. Выразительные наименования

**Принцип**: Имена функций, переменных и классов должны четко выражать их назначение, контекст и отражать понятия предметной области.

Избегайте сокращений и неочевидных аббревиатур. Глаголы для функций, существительные для объектов, конкретность вместо абстрактности. Хорошее имя отвечает не только на вопрос "что это?", но и "зачем это?". Правильное именование – это документация, встроенная в код.

## 8. Явные связи между сущностями

**Принцип**: Связи между сущностями должны быть явными, предсказуемыми и отражать реальные отношения в предметной области.

Делайте зависимости видимыми через параметры конструкторов или аргументы функций. Избегайте глобальных состояний и неявных сайд-эффектов. Явные связи помогают разработчикам легко отследить, на что повлияют их изменения, что снижает стоимость поддержки кода.

## 9. Прозрачное управление состоянием

**Принцип**: Используйте явные переходы состояний, контекстно-зависимые операции и изолируйте изменения состояния.

Состояния должны меняться через четко определенные операции, с проверками валидности переходов. Предпочитайте неизменяемые структуры данных там, где это возможно. Инкапсулируйте состояние внутри соответствующих объектов, предоставляя контролируемые интерфейсы для его изменения.

## 10. Разделение бизнес-логики и инфраструктуры

**Принцип**: Изолируйте бизнес-логику от деталей инфраструктуры (БД, HTTP, внешние API).

Бизнес-логика должна оперировать абстракциями, а не конкретными реализациями инфраструктурных компонентов. Это делает ядро приложения более стабильным и независимым от технологических изменений. Используйте принцип инверсии зависимостей, чтобы код ядра не зависел от конкретных реализаций инфраструктуры.

## 11. Немедленная валидация параметров

**Принцип**: Проверяйте входные данные на корректность в самом начале функции с быстрым выходом при невыполнении условий.

Раннее обнаружение проблем предотвращает каскадные ошибки и упрощает отладку. Проверка параметров должна быть явной и исчерпывающей. При невыполнении условий быстро возвращайте ошибку с понятным сообщением, чтобы немедленно сигнализировать о проблеме.

## 12. Атомарные транзакции с защитой от гонок

**Принцип**: Используйте явные блокировки ресурсов и транзакции для обеспечения целостности данных в многопоточной среде.

Применяйте оптимистичные и пессимистичные блокировки в зависимости от контекста, обеспечивайте изоляцию операций при параллельном доступе. Понимайте и грамотно применяйте различные стратегии обеспечения целостности данных в зависимости от требований задачи.

## 13. Сложность определяется пониманием, а не размером

**Принцип**: Сложность кода определяется не количеством строк, а когнитивными усилиями, необходимыми для его понимания.

Ясный и понятный код, даже если он длиннее, лучше короткого, но запутанного. Добавляйте документацию к сложным алгоритмам, но избегайте комментариев к очевидному коду. Приоритизируйте читаемость и понятность над краткостью, особенно в критичных частях системы.

## 14. Современный Python

**Принцип**: Используйте современные возможности языка для повышения ясности и безопасности кода.

Применяйте аннотации типов, контекстные менеджеры, pathlib вместо os.path, статическую типизацию аргументов и возвращаемых значений. Современные языковые конструкции делают код более декларативным и безопасным, уменьшая вероятность ошибок и улучшая читаемость.

## 15. Тестируемость

**Принцип**: Проектируйте код так, чтобы его было легко тестировать автоматически.

Создавайте чистые функции, не зависящие от состояния, изолируйте сторонние эффекты, используйте явные входные и выходные параметры. Тестируемый код обычно оказывается более модульным и менее связанным, что улучшает общее качество системы и снижает риск регрессий при изменениях.

## 16. Точное понимание проблемной области

**Принцип**: Прежде чем писать код, убедитесь в точном понимании проблемы. Неправильная интерпретация задачи ведет к неэффективным решениям.

**Применение**: 
- Задавайте уточняющие вопросы
- Проверяйте свое понимание на простых примерах
- Анализируйте существующий код перед написанием нового

## 17. Предотвращение логических deadlock'ов в дизайне

**Принцип**: Проектируйте системы координации так, чтобы исключить возможность логических тупиков на уровне архитектуры.

**Применение**:
- Анализируйте зависимости событий на этапе проектирования
- Избегайте циклических ожиданий в lifecycle компонентов
- Проверяйте возможность достижения всех состояний системы


## 18. Принцип минимально достаточного решения

**Принцип**: Создавайте решение ровно той сложности, которая требуется для решения задачи. Избыточная сложность - признак неточного понимания проблемы.

**Применение**:
- Начинайте с самого простого решения
- Усложняйте только при появлении конкретных ограничений текущего подхода
- Регулярно пересматривайте сложность решения относительно задачи

## 19. Безжалостное удаление неиспользуемого кода

**Принцип**: Активно выявляйте и удаляйте код, который не вносит вклад в решение текущих задач.

**Применение**:
- Удаляйте код сразу, как только он перестал использоваться
- Не сохраняйте код "на всякий случай" - используйте систему контроля версий
- Предпочитайте переписать заново, чем адаптировать неподходящий код

## 20. Конкретные техники защиты от Error Hiding

**Принцип**: Применяйте конкретные техники для предотвращения проглатывания исключений. См. принцип 2A для общей архитектуры.

**Жёсткие правила**:
1. `try-except Exception` без re-raise — запрещён
2. Возврат default-значений (None/0/[]) вместо exception — запрещён
3. Логирование ошибки и продолжение работы — запрещено
4. Пометка как "успешно обработано" при фактическом пропуске — запрещена

**Результат обработки должен быть отражён в данных, не только в логах**:

Лог — это мёртвое сообщение. Его никто не читает в реальном времени. Если ошибка записана только в лог, она потеряна. Нельзя обманывать самих себя — если обработка не удалась, это должно быть явно видно в данных.

```python
# ❌ Semantic Error Hiding — обман самих себя
except Config.DoesNotExist:
    logger.warning('Config not found, skipping')  # Мёртвое сообщение
    event.status = 'PROCESSED'  # Ложь! Результата нет
    return None

# ✅ Честное отражение результата
except Config.DoesNotExist as e:
    event.status = 'FAILED'
    event.error_message = str(e)
    event.save()
    # Теперь ошибка видна в данных, её можно найти и исправить
```

**Иерархия реакции на ошибку**:
1. Есть поле статуса → `status = FAILED`, `error_message = str(e)`
2. Нет поля статуса, но есть другой способ → использовать его (таблица ошибок, метрика)
3. Нет никакого способа отразить → `raise` — пусть падает, это лучше чем молчаливая потеря

**Легитимные случаи try-catch**:
```python
# ✅ Re-raise с обогащением контекста
try:
    result = external_api.call()
except ExternalApiError as e:
    raise ServiceError(f"Failed to call API for user_id={user_id}") from e

# ✅ Преобразование в доменное исключение
try:
    data = json.loads(raw)
except json.JSONDecodeError as e:
    raise InvalidDataFormat(f"Cannot parse response: {raw[:100]}") from e

# ❌ Error Hiding - запрещено
try:
    do_something()
except Exception:
    logger.error("Failed")  # Проглатывание исключения!
    return None
```

**Применение**:
- Избегайте blanket `except Exception` без re-raise
- Логируйте с `exc_info=True` для стектрейса
- Используйте `raise ... from e` для chain exceptions
- В тестах: `pytest.fail()` вместо `raise TimeoutError()` (защита от Error Hiding в pytest)


## 21. Внешнее взаимодействие с пределом ожидания

**Принцип**: Не рассчитывайте что внешний сервис вам ответит. Всегда выставляйте timeout для сетевых коммуникаций, заранее определяйте границы вашего ожидания. От этого зависит SLO.

## 22. Контекстно-адаптивные значения по умолчанию

**Принцип**: Значения по умолчанию определяются контекстом потребителя, а не свойствами объекта. Зависимостям — минимум для валидности, точкам входа — максимум для пользы.

Один и тот же концепт может иметь разные defaults в зависимости от роли в коде:

| Роль | Defaults | Причина |
|------|----------|---------|
| Зависимость (FK, import) | Минимально валидные | Потребителю не важны детали |
| Точка входа (API, factory) | Максимально полезные | Потребитель хочет работать, не настраивать |
| Edge case | Явно отличающиеся | Отклонение должно быть видимым |

**Применение**:
- При создании фабрик/fixtures определяйте контекст использования
- FK-зависимости получают минимальный валидный объект
- Публичные API получают богатые defaults для типичного сценария
- Edge cases маркируются явными параметрами (`with_feature=False`)

**Критерий**: Вызов компонента без параметров должен делать "правильную вещь" для своего контекста. Разработчик может использовать компонент без документации, и результат соответствует ожиданиям.

**Антипаттерн**: Единые defaults для всех контекстов. Если FK-фабрика создаёт "полный" объект — это лишняя работа. Если публичный API требует обязательной настройки типичного случая — это лишняя когнитивная нагрузка.

**ВАЖНО: Default ≠ Error Hiding**

Возврат "пустого" значения при ошибке — это НЕ "поведение по умолчанию", это Error Hiding (см. принцип 20). Различайте:

| Ситуация | Правильное поведение |
|----------|---------------------|
| Данных нет (легитимно) | `return None` — это default |
| Данные есть, но ошибка парсинга | `raise` — это баг, нужно знать |
| Внешний API вернул ошибку | `raise` — нужно знать о проблеме |

Принцип: если данные **могут** быть получены, они **должны** быть корректно обработаны. Ошибка обработки — не повод возвращать default.

```python
# ✅ FK-зависимость: минимум для валидности
@pytest.fixture()
def campaign(db) -> Campaign:
    return Campaign.objects.create(name='Test', status=CampaignStatus.ACTIVE)

# ✅ Точка входа: максимум для пользы
def create_applicant(
    with_tilda: bool = True,  # По умолчанию = типичный сценарий
    tilda_position: str = 'backend',
    telegram: str = '@testuser',
): ...

# ✅ Edge case: явное отклонение
applicant = create_applicant(with_tilda=False)  # Миграционный сценарий

# ❌ Error Hiding под видом default
def fetch_data(id):
    try:
        return api.get(id)
    except Exception:
        return None  # НЕТ! Это скрывает ошибку API

# ✅ Fail fast, default только для легитимного отсутствия
def fetch_data(id):
    response = api.get(id)  # Пусть падает при ошибке API
    if not response.data:
        return None  # Данных нет — это легитимный default
    return parse(response.data)  # Пусть падает при ошибке парсинга
```