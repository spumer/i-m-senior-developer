# Style Guide "Функциональная ясность"

## 1. Простые, однозадачные функции

- Каждая функция решает одну задачу
- Минимум побочных эффектов
- Длина функции не более 20-30 строк

**Критерий**: если функцию сложно назвать одним глаголом — она делает слишком много.

## 2. Явная обработка ошибок

- Fail-fast при невалидных входных данных, избегаем лишних try/finally
- Создаем собственные классы исключений при необходимости
- Информативные классы исключений с говорящими названиями
- Подробные сообщения об ошибках с контекстом

```python
# Хорошо: собственное исключение с контекстом
class OrderProcessingError(Exception):
    def __init__(self, order_id: int, reason: str):
        super().__init__(f"Cannot process order {order_id}: {reason}")
        self.order_id = order_id

# Хорошо: fail-fast валидация
def calculate_discount(order: Order) -> Decimal:
    if not order.items:
        raise ValueError(f"Order {order.id} has no items")
    ...
```

## 3. Минимальные зависимости

- Избегать излишних абстракций
- Предпочитать стандартную библиотеку
- Инкапсулировать внешние зависимости за интерфейсами
- Изолировать через фабрики и сервисы

## 4. Документация и наименования

- Говорящие имена функций и переменных
- Docstrings с подробным описанием аргументов, результатов и ошибок
- Комментарии для сложных алгоритмов, но не для очевидного кода

```python
# Плохо: что делает функция?
def proc(d, t):
    ...

# Хорошо: имя отвечает на "что?" и "зачем?"
def calculate_delivery_cost(order: Order, tariff: Tariff) -> Decimal:
    ...
```

## 5. Организация кода

- Публичный API с четким интерфейсом
- Функции-помощники скрыты от внешнего пользователя (prefix `_`)
- Группировка по функциональности, не по типу

```python
# Плохо: группировка по типу
# utils.py, validators.py, serializers.py

# Хорошо: группировка по функциональности
# orders/processing.py — всё что связано с обработкой заказов
# orders/pricing.py — всё что связано с ценообразованием
```

## 6. Тестируемость

- Чистые функции, не зависящие от состояния
- Изоляция сторонних эффектов
- Явные входные и выходные параметры
- **Error Hiding антипаттерн**: В тестах используйте `pytest.fail()` вместо `raise TimeoutError()`. Обычные исключения подвержены Error Hiding — поглощению исключений промежуточными слоями кода

```python
# Правильно — pytest.fail() не перехватывается
if not event.wait(timeout=2.0):
    pytest.fail(f'Test design error: timeout waiting for {event_key=}')

# Неправильно — исключение может быть поглощено
if not event.wait(timeout=2.0):
    raise TimeoutError(f'Test design error: {event_key=}')
```

## 7. Timeout как обязательная защита

**Принцип**: Все блокирующие операции в тестах должны иметь timeout для предотвращения зависания. Все внешние вызовы должны иметь timeout.

**Критическое замечание**: Timeout не должен маскировать логические ошибки. Если функционал зависает без timeout — это сигнал о проблеме в логике, а не повод добавить timeout.

```python
# Внешний вызов — всегда с timeout
response = httpx.get(url, timeout=5.0)

# Блокирующая операция в тесте — timeout + pytest.fail
if not event.wait(timeout=2.0):
    pytest.fail(f'Timeout: {event_key=}')
```
